<!DOCTYPE html>
<html>

<head>
    <title>containerized-development-environment</title>
    <meta http-equiv="Content-type" content="text/html;charset=utf-8" />
    <meta name="Description" content="Learning Rust Wasm/Webassembly programming and having fun">
    <meta name="author" content="https://github.com/bestia-dev">
    <meta name=viewport content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/bestia01.css">
    <script>
        /* Toggle between adding and removing the "responsive" class to navbar when the user clicks on the hamburger */
        function toggle_responsive_navbar() {
            var x = document.getElementById("navbar");
            if (x.className.includes(" responsive")) {
                x.className = x.className.replace(" responsive", "");
            } else {
                x.className += " responsive";
            }
        }
    </script>
</head>

<body>
    <div class="fixed_header">
        <div id="navbar">
            <a id="navbar_brand" href="https://bestia.dev">
                <img src="bestia_icon.png" alt="Bestia development" title="bestia.dev" />
                <span id="navbar_title"> Bestia dev</span>
            </a>
            <a id="navbar_hamburger" href="javascript:void(0);" onclick="toggle_responsive_navbar()">☰ </a>
            <div id="navbar_topics">
                <a href="/index.html#home" onclick="toggle_responsive_navbar()">Home </a>
                <a href="/index.html#tutorials" onclick="toggle_responsive_navbar()">Tutorials</a>
                <a href="/index.html#games" onclick="toggle_responsive_navbar()">Games</a>
                <a href="/index.html#productivity" onclick="toggle_responsive_navbar()">Productivity</a>
                <a href="/index.html#contact" onclick="toggle_responsive_navbar()">Contact</a>
            </div>
        </div>        
    </div>
    <div>&nbsp;</div> 
    <div class="small">This is a copy of the Substack article.<br/>
    Find the original on <a href="https://bestiadev.substack.com/p/containerized-development-environment">https://bestiadev.substack.com/p/containerized-development-environment</a>.<br/>
    Article date: 2023-05-12T13:16:10.840Z</div>

<article class="typography newsletter-post post"><div class="post-header"><h1 class="post-title unpublished">Containerized development environment for the Rust programming language</h1><h3 class="subtitle">Simple, repeatable, coherent, savable, and isolated</h3></div><div class="visibility-check"></div><div class class><div class="available-content"><div dir="auto" class="body markup"><h2 class="header-with-anchor-widget">Benefits</h2><p>The benefits of having a development environment inside a Linux container are many:</p><p><strong>1. Simple run without installation</strong><br /><span>    The Linux container is just downloaded and run on any system (Linux, Windows WSL2, and MacOS). No need to learn how to install programs and configure the system.</span><br /><span>    The container has already installed all programs with configurations for basic Rust development.</span></p><p><strong>2. Simple reset of the environment</strong><br /><span>    If something goes wrong inside the container, it is easy to reset everything. Just delete the container and run a new fresh one.</span></p><p><strong>3.  Repetitive build of the container image</strong><br /><span>    When a tool needs to be updated or upgraded, it is easy to change the script and repeat the container image build.</span><br /><span>    Then we save the image on Docker Hub and all other developers can just pull it and run it.</span></p><p><strong>4. Extend the container image for specific purposes</strong><br /><span>    When in need of some specific tools, it is easy to build a new container image from the basic image with added functionality.	</span><br /><span>    The build script starts with the basic image, installs programs, and set configurations. It is repeatable, customizable, and easily distributable.</span></p><p><strong>5. Coherent environment between developers</strong><br /><span>    More developers can collaborate on the same project easily when they use the same developing environment.</span></p><p><strong>6. Saving an exact point in the development</strong><br /><span>    When a project is not developed for a long time, many things can change, OS version, compiler, other developer tools, libraries,...</span><br /><span>    It is difficult/impossible to recreate the same development environment after some time. </span><br /><span>    Because of containers, we can save the exact development environment when the project was actively developed.</span><br /><span>    Later we can then use exactly the same environment in the same shape and form.</span></p><p><strong>7. Isolation</strong><br /><span>    Programming is a complex matter. It needs many tools, programs, configurations, and libraries. </span><br /><span>    Sometimes we experiment and we can not trust just everybody.</span><br /><span>    Work inside the container is isolated from the host system, it does not have access to files and the whole network.</span><br /><span>    The dev. env. has a customizable firewall to whitelist only the network places that are strictly needed.</span><br /><span>    I admit, containers are not perfectly isolated, but it is hard to crack them and it is better than just leaving everything at the mercy of unknown programs.</span><br /><span>    Execution is isolated in the development time and runtime of the compiled programs.</span></p><p><strong>8. Remote Git repository</strong><br /><span>    Containers are ephemeral and are easily deleted. It is even recommended to delete them from time to time.</span><br /><span>    The source code must therefore be pushed to a remote git repository. So we can pull it from the repository when we have a fresh container.</span><br /><span>    By doing this, we are sure there are no files or information we forgot to add to the repository or instructions.</span></p><h2 class="header-with-anchor-widget">Repository</h2><p>The repository with all the scripts and thorough information about this project are on GitHub and some instructions are also on YouTube.</p><p>//github.com/CRUSTDE-ContainerizedRustDevEnv/crustde_cnt_img_pod</p><p>//bestia.dev/youtube/crustde_cnt_img_pod.html</p><h2 class="header-with-anchor-widget">Basic Rust dev. container `crustde_cargo_img`</h2><p>This container has all the tools that are needed for Rust programming. Except for the code editor, because developers’ preferences differ. The content of the containers is transparent and observable by reading the bash script. </p><p>Basic and advanced functionality: </p><ul><li><p><span>slim Debian OS with curl, git, </span><code>rsync, nano, ssh, build-essentials </code></p></li><li><p>non-privileged user/container with Podman</p></li><li><p>Rust tools, compiler, docs, source</p></li><li><p>much faster `mold` linker</p></li><li><p>cross-compile to Windows, musl, and Webassembly/Wasm</p></li><li><p>automation tasks cargo-auto</p></li><li><p>compilation artifact cache - sccache</p></li></ul><p>These are most of the commands to build the container image (from the bash script):</p><p><code><span>from Debian:bullseye-slim</span><br /><span>apt -y update</span><br /><span>apt -y full-upgrade</span><br /><span>apt install -y curl</span><br /><span>apt install -y git</span><br /><span>apt install -y rsync</span><br /><span>apt install -y build-essential</span><br /><span>apt install -y nano</span><br /><span>apt install -y procps</span><br /><span>apt install -y pkg-config</span><br /><span>apt install -y libssl-dev</span><br /><span>apt install -y postgresql-client</span><br /><span>useradd -ms /bin/bash rustdevuser</span><br /><span>mkdir -vp ~/rustprojects</span><br /><span>mkdir -vp ~/.ssh</span><br /><span>chmod 700 ~/.ssh</span><br /><span>curl https://sh.rustup.rs -sSf | sh -s -- -yq</span><br /><span>rustup component add rust-src</span><br /><span>apt-get install -y mingw-w64</span><br /><span>rustup target add x86_64-pc-windows-gnu</span><br /><span>apt-get install -y musl-tools</span><br /><span>rustup target add x86_64-unknown-linux-musl</span><br /><span>copy crustde_cargo_img  'mold' '/usr/bin/'</span><br /><span>mkdir /home/rustdevuser/.cargo/bin/mold</span><br /><span>ln -s /usr/bin/mold /home/rustdevuser/.cargo/bin/mold/ld</span><br /><span>cargo install cargo-auto</span><br /><span>curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh</span><br /><span>cargo install dev_bestia_cargo_completion</span><br /><span>cargo install sccache</span><br /><span>mkdir /home/rustdevuser/.ssh/crustde_pod_keys</span><br /><span>copy crustde_cargo_img 'cargo_config.toml' '/home/rustdevuser/.cargo/config.toml'</span><br /><span>apt -y autoremove</span><br /><span>apt -y clean</span></code></p><h2 class="header-with-anchor-widget">VSCode editor container `crustde_vscode_img`</h2><p>I prefer the VSCode editor. I build a container image that contains the server part of VSCode with my favorite extensions. Then the client GUI part of VSCode can connect over SSH to the VSCode server from any OS. </p><p>VSCode functionality: </p><ul><li><p>VSCode server</p></li><li><p>code completion, syntax highlighting</p></li><li><p><code>basic spell-checker that works well with code and documents</code></p></li><li><p><code>Markdown linting and style checking</code></p></li><li><p>matching brackets to be identified with colors</p></li><li><p>XML Formatting</p></li><li><p>helper for dependencies in Cargo.toml</p></li><li><p>preview webpages with a local webserver</p></li><li><p>Database Management SQLTools</p></li></ul><p>Some commands from the bash script:</p><p><code><span>from crustde_cargo_img</span><br /><span>apt install -y openssh-server</span><br /><span>mkdir -vp ~/.vscode-server/bin/commit-sha</span><br /><span>mkdir -vp ~/.vscode-server/extensions</span><br /><span>curl -L -s https://update.code.visualstudio.com/commit-sha/server-linux-64/stable --output x.tar.gz</span><br /><span>tar --no-same-owner -xzv --strip-components=1 -C ~/.vscode-server/bin/commit-sha-f x.tar.gz</span><br /><span>rm /tmp/vscode-server-linux-x64.tar.gz</span><br /><span>code-server --install-extension streetsidesoftware.code-spell-checker</span><br /><span>code-server --install-extension rust-lang.rust-analyzer</span><br /><span>code-server --install-extension davidanson.vscode-markdownlint</span><br /><span>code-server --install-extension 2gua.rainbow-brackets</span><br /><span>code-server --install-extension dotjoshjohnson.xml</span><br /><span>code-server --install-extension serayuzgur.crates</span><br /><span>code-server --install-extension ms-vscode.live-server</span><br /><span>code-server --install-extension mtxr.sqltools</span><br /><span>code-server --ins</span></code><span>tall-extension mtxr.sqltools-driver-pg</span></p><h2 class="header-with-anchor-widget">Typescript container rust_ts_dev_vscode_img</h2><p>For projects that need Typescript and Rust, I built a specialized container image with these commands:</p><p><code><span>from rust_ts_dev_vscode_img</span><br /><span>apt install -y nodejs npm</span><br /><span>npm install -g typescript</span></code></p><h2 class="header-with-anchor-widget">Create pod crustde_pod</h2><p>The single container is not enough. For many development purposes, we need more than one container. We can group them in a `pod`. I use `podman` for that. In this phase, we must copy our secrets to the container like ssh keys for GitHub and the production web server. I use the squid container to limit the network connection only to whitelisted places. I start the ssh server, so I can connect VSCode over ssh.</p><p><code><span>add crustde_squid_cnt</span><br /><span>cp etc_squid_squid.conf crustde_squid_cnt:/etc/squid/squid.conf</span><br /><span>add crustde_vscode_cnt</span><br /><span>cp ~/.ssh/crustde_pod_keys/etc_ssh_sshd_config.conf crustde_vscode_cnt:/etc/ssh/sshd_config</span><br /><span>cp ~/.ssh/crustde_pod_keys/etc/ssh/ssh_host_ed25519_key  crustde_vscode_cnt:/etc/ssh/ssh_host_ed25519_key</span><br /><span>cp ~/.ssh/crustde_pod_keys/etc/ssh/ssh_host_ed25519_key.pub  crustde_vscode_cnt:/etc/ssh/ssh_host_ed25519_key.pub</span><br /><span>cp ~/.ssh/crustde_rustdevuser_ssh_1.pub crustde_vscode_cnt:~/.ssh/crustde_rustdevuser_ssh_1.pub</span><br /><span>cp ~/.ssh/rustdevuser_rsa_key.pub crustde_vscode_cnt:~/.ssh/rustdevuser_rsa_key.pub</span><br /><span>pod start crustde_pod</span><br /><span>git config --global pull.rebase false</span><br /><span>sh ~/.ssh/crustde_pod_keys/personal_keys_and_settings.sh</span><br /><span>crustde_vscode_cnt service ssh restart</span></code></p><h2 class="header-with-anchor-widget">Virtual machines</h2><p>Another way to create a development environment is by using virtual machines. That sounds great, but they are big and slow.</p><p>I know standard Linux OCI containers are not real virtual machines. They are also not perfectly sandboxed. There exist vulnerabilities that can be exploited to get access to the host machine. But that is hard to do and is patched day by day. There are also efforts to make containers more isolated like gVisor or Kata Containers. So the future is bright. Very importantly the development container runs in unprivileged mode with Podman.</p><h2 class="header-with-anchor-widget">Rust development is “not safe”</h2><p>I am very interested in Rust because I think it can become very safe in many aspects, not just memory-safe. I think developing Rust on bare metal is &quot;not safe&quot; and should NOT be recommended.</p><p>In a normal Rust program, we use hundreds of open-source libraries, including the transient dependencies. We cannot trust all of them and it is impossible to check the code of all. So the starting point is that we are just lucky if none of the hundreds of dependency versions is malicious. Sooner or later it will happen. </p><p>Even before we compile our program the rust-analyzer will compile the dependency libraries to help us with code completion. Doing that will run the build.rs code that can do anything on our system. It can delete or replace any file we have access to. Very bad and not trustworthy!</p><p>The same is true when compiling and later when running compiled programs.</p><p>We also use many developer tools (programs); each can be problematic and have access to the whole system.</p><p>So, it is “not safe&quot; to develop Rust programs on a bare metal machine. Using Linux OCI containers is much better.</p><h2 class="header-with-anchor-widget"><strong>open-source and free as a beer</strong></h2><p><span>My open-source projects are free as a beer (MIT license).</span><br /><span>I just love programming.</span><br /><span>But I need also to drink. If you find my projects and tutorials helpful, please buy me a beer by donating to my </span><a href="https://paypal.me/LucianoBestia">PayPal</a><span>.</span><br /><span>You know the price of a beer in your local bar ;-) So I can drink a free beer for your health :-)</span></p><p><a href="https://translate.google.com/?hl=en&amp;sl=sl&amp;tl=en&amp;text=Na%20zdravje&amp;op=translate">Na zdravje!</a><span> </span><a href="https://dictionary.cambridge.org/dictionary/italian-english/alla-salute">Alla salute!</a><span> </span><a href="https://dictionary.cambridge.org/dictionary/german-english/prost">Prost!</a><span> </span><a href="https://matadornetwork.com/nights/how-to-say-cheers-in-50-languages/">Nazdravlje!</a><span> 🍻</span></p><p><a href="https://bestia.dev/">//bestia.dev</a><br /><a href="https://github.com/bestia-dev">//github.com/bestia-dev</a><br /><a href="https://bestiadev.substack.com/">//bestiadev.substack.com</a><br /><a href="https://www.youtube.com/@bestia-dev-tutorials">//youtube.com/@bestia-dev-tutorials</a></p></div></div><div class="visibility-check"></div></div></article>
</body>

</html>